{"ast":null,"code":"import _get from \"@babel/runtime/helpers/get\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _extends from \"@babel/runtime/helpers/extends\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport prefetchHelper from \"./prefetch\";\nimport emitter from \"./emitter\";\nimport { setMatchPaths, findPath, findMatchPath as _findMatchPath } from \"./find-path\";\nexport var PageResourceStatus = {\n  Error: \"error\",\n  Success: \"success\"\n};\n\nvar preferDefault = function preferDefault(m) {\n  return m && m.default || m;\n};\n\nvar stripSurroundingSlashes = function stripSurroundingSlashes(s) {\n  s = s[0] === \"/\" ? s.slice(1) : s;\n  s = s.endsWith(\"/\") ? s.slice(0, -1) : s;\n  return s;\n};\n\nvar createPageDataUrl = function createPageDataUrl(path) {\n  var fixedPath = path === \"/\" ? \"index\" : stripSurroundingSlashes(path);\n  return __PATH_PREFIX__ + \"/page-data/\" + fixedPath + \"/page-data.json\";\n};\n\nvar doFetch = function doFetch(url) {\n  var method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"GET\";\n  return new Promise(function (resolve, reject) {\n    var req = new XMLHttpRequest();\n    req.open(method, url, true);\n\n    req.onreadystatechange = function () {\n      if (req.readyState == 4) {\n        resolve(req);\n      }\n    };\n\n    req.send(null);\n  });\n};\n\nvar _loadPageDataJson = function loadPageDataJson(loadObj) {\n  var pagePath = loadObj.pagePath,\n      _loadObj$retries = loadObj.retries,\n      retries = _loadObj$retries === void 0 ? 0 : _loadObj$retries;\n  var url = createPageDataUrl(pagePath);\n  return doFetch(url).then(function (req) {\n    var status = req.status,\n        responseText = req.responseText;\n\n    if (status === 200) {\n      try {\n        var jsonPayload = JSON.parse(responseText);\n\n        if (jsonPayload.path === undefined) {\n          throw new Error(\"not a valid pageData response\");\n        }\n\n        return _extends(loadObj, {\n          status: PageResourceStatus.Success,\n          payload: jsonPayload\n        });\n      } catch (err) {}\n    }\n\n    if (status === 404 || status === 200) {\n      if (pagePath === \"/404.html\") {\n        return _extends(loadObj, {\n          status: PageResourceStatus.Error\n        });\n      }\n\n      return _loadPageDataJson(_extends(loadObj, {\n        pagePath: \"/404.html\",\n        notFound: true\n      }));\n    }\n\n    if (status === 500) {\n      return _extends(loadObj, {\n        status: PageResourceStatus.Error\n      });\n    }\n\n    if (retries < 3) {\n      return _loadPageDataJson(_extends(loadObj, {\n        retries: retries + 1\n      }));\n    }\n\n    return _extends(loadObj, {\n      status: PageResourceStatus.Error\n    });\n  });\n};\n\nvar doesConnectionSupportPrefetch = function doesConnectionSupportPrefetch() {\n  if (\"connection\" in navigator && typeof navigator.connection !== \"undefined\") {\n    if ((navigator.connection.effectiveType || \"\").includes(\"2g\")) {\n      return false;\n    }\n\n    if (navigator.connection.saveData) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nvar toPageResources = function toPageResources(pageData) {\n  var component = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var page = {\n    componentChunkName: pageData.componentChunkName,\n    path: pageData.path,\n    webpackCompilationHash: pageData.webpackCompilationHash,\n    matchPath: pageData.matchPath\n  };\n  return {\n    component: component,\n    json: pageData.result,\n    page: page\n  };\n};\n\nexport var BaseLoader = function () {\n  function BaseLoader(loadComponent, matchPaths) {\n    _classCallCheck(this, BaseLoader);\n\n    this.pageDb = new Map();\n    this.inFlightDb = new Map();\n    this.pageDataDb = new Map();\n    this.prefetchTriggered = new Set();\n    this.prefetchCompleted = new Set();\n    this.loadComponent = loadComponent;\n    setMatchPaths(matchPaths);\n  }\n\n  _createClass(BaseLoader, [{\n    key: \"setApiRunner\",\n    value: function setApiRunner(apiRunner) {\n      this.apiRunner = apiRunner;\n      this.prefetchDisabled = apiRunner(\"disableCorePrefetching\").some(function (a) {\n        return a;\n      });\n    }\n  }, {\n    key: \"loadPageDataJson\",\n    value: function loadPageDataJson(rawPath) {\n      var _this = this;\n\n      var pagePath = findPath(rawPath);\n\n      if (this.pageDataDb.has(pagePath)) {\n        return Promise.resolve(this.pageDataDb.get(pagePath));\n      }\n\n      return _loadPageDataJson({\n        pagePath: pagePath\n      }).then(function (pageData) {\n        _this.pageDataDb.set(pagePath, pageData);\n\n        return pageData;\n      });\n    }\n  }, {\n    key: \"findMatchPath\",\n    value: function findMatchPath(rawPath) {\n      return _findMatchPath(rawPath);\n    }\n  }, {\n    key: \"loadPage\",\n    value: function loadPage(rawPath) {\n      var _this2 = this;\n\n      var pagePath = findPath(rawPath);\n\n      if (this.pageDb.has(pagePath)) {\n        var page = this.pageDb.get(pagePath);\n        return Promise.resolve(page.payload);\n      }\n\n      if (this.inFlightDb.has(pagePath)) {\n        return this.inFlightDb.get(pagePath);\n      }\n\n      var inFlight = Promise.all([this.loadAppData(), this.loadPageDataJson(pagePath)]).then(function (allData) {\n        var result = allData[1];\n\n        if (result.status === PageResourceStatus.Error) {\n          return {\n            status: PageResourceStatus.Error\n          };\n        }\n\n        var pageData = result.payload;\n        var _pageData = pageData,\n            componentChunkName = _pageData.componentChunkName;\n        return _this2.loadComponent(componentChunkName).then(function (component) {\n          var finalResult = {\n            createdAt: new Date()\n          };\n          var pageResources;\n\n          if (!component) {\n            finalResult.status = PageResourceStatus.Error;\n          } else {\n            finalResult.status = PageResourceStatus.Success;\n\n            if (result.notFound === true) {\n              finalResult.notFound = true;\n            }\n\n            pageData = _extends(pageData, {\n              webpackCompilationHash: allData[0] ? allData[0].webpackCompilationHash : \"\"\n            });\n            pageResources = toPageResources(pageData, component);\n            finalResult.payload = pageResources;\n            emitter.emit(\"onPostLoadPageResources\", {\n              page: pageResources,\n              pageResources: pageResources\n            });\n          }\n\n          _this2.pageDb.set(pagePath, finalResult);\n\n          return pageResources;\n        });\n      }).then(function (response) {\n        _this2.inFlightDb.delete(pagePath);\n\n        return response;\n      }).catch(function (err) {\n        _this2.inFlightDb.delete(pagePath);\n\n        throw err;\n      });\n      this.inFlightDb.set(pagePath, inFlight);\n      return inFlight;\n    }\n  }, {\n    key: \"loadPageSync\",\n    value: function loadPageSync(rawPath) {\n      var pagePath = findPath(rawPath);\n\n      if (this.pageDb.has(pagePath)) {\n        return this.pageDb.get(pagePath).payload;\n      }\n\n      return undefined;\n    }\n  }, {\n    key: \"shouldPrefetch\",\n    value: function shouldPrefetch(pagePath) {\n      if (!doesConnectionSupportPrefetch()) {\n        return false;\n      }\n\n      if (this.pageDb.has(pagePath)) {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"prefetch\",\n    value: function prefetch(pagePath) {\n      var _this3 = this;\n\n      if (!this.shouldPrefetch(pagePath)) {\n        return false;\n      }\n\n      if (!this.prefetchTriggered.has(pagePath)) {\n        this.apiRunner(\"onPrefetchPathname\", {\n          pathname: pagePath\n        });\n        this.prefetchTriggered.add(pagePath);\n      }\n\n      if (this.prefetchDisabled) {\n        return false;\n      }\n\n      var realPath = findPath(pagePath);\n      this.doPrefetch(realPath).then(function () {\n        if (!_this3.prefetchCompleted.has(pagePath)) {\n          _this3.apiRunner(\"onPostPrefetchPathname\", {\n            pathname: pagePath\n          });\n\n          _this3.prefetchCompleted.add(pagePath);\n        }\n      });\n      return true;\n    }\n  }, {\n    key: \"doPrefetch\",\n    value: function doPrefetch(pagePath) {\n      throw new Error(\"doPrefetch not implemented\");\n    }\n  }, {\n    key: \"hovering\",\n    value: function hovering(rawPath) {\n      this.loadPage(rawPath);\n    }\n  }, {\n    key: \"getResourceURLsForPathname\",\n    value: function getResourceURLsForPathname(rawPath) {\n      var pagePath = findPath(rawPath);\n      var page = this.pageDataDb.get(pagePath);\n\n      if (page) {\n        var pageResources = toPageResources(page.payload);\n        return [].concat(_toConsumableArray(createComponentUrls(pageResources.page.componentChunkName)), [createPageDataUrl(pagePath)]);\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: \"isPageNotFound\",\n    value: function isPageNotFound(rawPath) {\n      var pagePath = findPath(rawPath);\n      var page = this.pageDb.get(pagePath);\n      return page && page.notFound === true;\n    }\n  }, {\n    key: \"loadAppData\",\n    value: function loadAppData() {\n      var _this4 = this;\n\n      var retries = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return doFetch(__PATH_PREFIX__ + \"/page-data/app-data.json\").then(function (req) {\n        var status = req.status,\n            responseText = req.responseText;\n        var appData;\n\n        if (status !== 200 && retries < 3) {\n          return _this4.loadAppData(retries + 1);\n        }\n\n        if (status === 200) {\n          try {\n            var jsonPayload = JSON.parse(responseText);\n\n            if (jsonPayload.webpackCompilationHash === undefined) {\n              throw new Error(\"not a valid app-data response\");\n            }\n\n            appData = jsonPayload;\n          } catch (err) {}\n        }\n\n        return appData;\n      });\n    }\n  }]);\n\n  return BaseLoader;\n}();\n\nvar createComponentUrls = function createComponentUrls(componentChunkName) {\n  return (window.___chunkMapping[componentChunkName] || []).map(function (chunk) {\n    return __PATH_PREFIX__ + chunk;\n  });\n};\n\nexport var ProdLoader = function (_BaseLoader) {\n  _inherits(ProdLoader, _BaseLoader);\n\n  var _super = _createSuper(ProdLoader);\n\n  function ProdLoader(asyncRequires, matchPaths) {\n    _classCallCheck(this, ProdLoader);\n\n    var loadComponent = function loadComponent(chunkName) {\n      return asyncRequires.components[chunkName] ? asyncRequires.components[chunkName]().then(preferDefault).catch(function () {\n        return null;\n      }) : Promise.resolve();\n    };\n\n    return _super.call(this, loadComponent, matchPaths);\n  }\n\n  _createClass(ProdLoader, [{\n    key: \"doPrefetch\",\n    value: function doPrefetch(pagePath) {\n      var _this5 = this;\n\n      var pageDataUrl = createPageDataUrl(pagePath);\n      return prefetchHelper(pageDataUrl, {\n        crossOrigin: \"anonymous\",\n        as: \"fetch\"\n      }).then(function () {\n        return _this5.loadPageDataJson(pagePath);\n      }).then(function (result) {\n        if (result.status !== PageResourceStatus.Success) {\n          return Promise.resolve();\n        }\n\n        var pageData = result.payload;\n        var chunkName = pageData.componentChunkName;\n        var componentUrls = createComponentUrls(chunkName);\n        return Promise.all(componentUrls.map(prefetchHelper)).then(function () {\n          return pageData;\n        });\n      });\n    }\n  }, {\n    key: \"loadPageDataJson\",\n    value: function loadPageDataJson(rawPath) {\n      return _get(_getPrototypeOf(ProdLoader.prototype), \"loadPageDataJson\", this).call(this, rawPath).then(function (data) {\n        if (data.notFound) {\n          return doFetch(rawPath, \"HEAD\").then(function (req) {\n            if (req.status === 200) {\n              return {\n                status: PageResourceStatus.Error\n              };\n            }\n\n            return data;\n          });\n        }\n\n        return data;\n      });\n    }\n  }]);\n\n  return ProdLoader;\n}(BaseLoader);\nvar instance;\nexport var setLoader = function setLoader(_loader) {\n  instance = _loader;\n};\nexport var publicLoader = {\n  getResourcesForPathname: function getResourcesForPathname(rawPath) {\n    console.warn(\"Warning: getResourcesForPathname is deprecated. Use loadPage instead\");\n    return instance.i.loadPage(rawPath);\n  },\n  getResourcesForPathnameSync: function getResourcesForPathnameSync(rawPath) {\n    console.warn(\"Warning: getResourcesForPathnameSync is deprecated. Use loadPageSync instead\");\n    return instance.i.loadPageSync(rawPath);\n  },\n  enqueue: function enqueue(rawPath) {\n    return instance.prefetch(rawPath);\n  },\n  getResourceURLsForPathname: function getResourceURLsForPathname(rawPath) {\n    return instance.getResourceURLsForPathname(rawPath);\n  },\n  loadPage: function loadPage(rawPath) {\n    return instance.loadPage(rawPath);\n  },\n  loadPageSync: function loadPageSync(rawPath) {\n    return instance.loadPageSync(rawPath);\n  },\n  prefetch: function prefetch(rawPath) {\n    return instance.prefetch(rawPath);\n  },\n  isPageNotFound: function isPageNotFound(rawPath) {\n    return instance.isPageNotFound(rawPath);\n  },\n  hovering: function hovering(rawPath) {\n    return instance.hovering(rawPath);\n  },\n  loadAppData: function loadAppData() {\n    return instance.loadAppData();\n  }\n};\nexport default publicLoader;","map":{"version":3,"sources":["/home/pc/Public/zenith/gatsby-firebase-starter-NEW/.cache/loader.js"],"names":["prefetchHelper","emitter","setMatchPaths","findPath","findMatchPath","PageResourceStatus","Error","Success","preferDefault","m","default","stripSurroundingSlashes","s","slice","endsWith","createPageDataUrl","path","fixedPath","__PATH_PREFIX__","doFetch","url","method","Promise","resolve","reject","req","XMLHttpRequest","open","onreadystatechange","readyState","send","loadPageDataJson","loadObj","pagePath","retries","then","status","responseText","jsonPayload","JSON","parse","undefined","payload","err","notFound","doesConnectionSupportPrefetch","navigator","connection","effectiveType","includes","saveData","toPageResources","pageData","component","page","componentChunkName","webpackCompilationHash","matchPath","json","result","BaseLoader","loadComponent","matchPaths","pageDb","Map","inFlightDb","pageDataDb","prefetchTriggered","Set","prefetchCompleted","apiRunner","prefetchDisabled","some","a","rawPath","has","get","set","inFlight","all","loadAppData","allData","finalResult","createdAt","Date","pageResources","emit","response","delete","catch","shouldPrefetch","pathname","add","realPath","doPrefetch","loadPage","createComponentUrls","appData","window","___chunkMapping","map","chunk","ProdLoader","asyncRequires","chunkName","components","pageDataUrl","crossOrigin","as","componentUrls","data","instance","setLoader","_loader","publicLoader","getResourcesForPathname","console","warn","i","getResourcesForPathnameSync","loadPageSync","enqueue","prefetch","getResourceURLsForPathname","isPageNotFound","hovering"],"mappings":"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","sourcesContent":["import prefetchHelper from \"./prefetch\"\nimport emitter from \"./emitter\"\nimport { setMatchPaths, findPath, findMatchPath } from \"./find-path\"\n\n/**\n * Available resource loading statuses\n */\nexport const PageResourceStatus = {\n  /**\n   * At least one of critical resources failed to load\n   */\n  Error: `error`,\n  /**\n   * Resources loaded successfully\n   */\n  Success: `success`,\n}\n\nconst preferDefault = m => (m && m.default) || m\n\nconst stripSurroundingSlashes = s => {\n  s = s[0] === `/` ? s.slice(1) : s\n  s = s.endsWith(`/`) ? s.slice(0, -1) : s\n  return s\n}\n\nconst createPageDataUrl = path => {\n  const fixedPath = path === `/` ? `index` : stripSurroundingSlashes(path)\n  return `${__PATH_PREFIX__}/page-data/${fixedPath}/page-data.json`\n}\n\nconst doFetch = (url, method = `GET`) =>\n  new Promise((resolve, reject) => {\n    const req = new XMLHttpRequest()\n    req.open(method, url, true)\n    req.onreadystatechange = () => {\n      if (req.readyState == 4) {\n        resolve(req)\n      }\n    }\n    req.send(null)\n  })\n\nconst loadPageDataJson = loadObj => {\n  const { pagePath, retries = 0 } = loadObj\n  const url = createPageDataUrl(pagePath)\n  return doFetch(url).then(req => {\n    const { status, responseText } = req\n\n    // Handle 200\n    if (status === 200) {\n      try {\n        const jsonPayload = JSON.parse(responseText)\n        if (jsonPayload.path === undefined) {\n          throw new Error(`not a valid pageData response`)\n        }\n\n        return Object.assign(loadObj, {\n          status: PageResourceStatus.Success,\n          payload: jsonPayload,\n        })\n      } catch (err) {\n        // continue regardless of error\n      }\n    }\n\n    // Handle 404\n    if (status === 404 || status === 200) {\n      // If the request was for a 404 page and it doesn't exist, we're done\n      if (pagePath === `/404.html`) {\n        return Object.assign(loadObj, {\n          status: PageResourceStatus.Error,\n        })\n      }\n\n      // Need some code here to cache the 404 request. In case\n      // multiple loadPageDataJsons result in 404s\n      return loadPageDataJson(\n        Object.assign(loadObj, { pagePath: `/404.html`, notFound: true })\n      )\n    }\n\n    // handle 500 response (Unrecoverable)\n    if (status === 500) {\n      return Object.assign(loadObj, {\n        status: PageResourceStatus.Error,\n      })\n    }\n\n    // Handle everything else, including status === 0, and 503s. Should retry\n    if (retries < 3) {\n      return loadPageDataJson(Object.assign(loadObj, { retries: retries + 1 }))\n    }\n\n    // Retried 3 times already, result is an error.\n    return Object.assign(loadObj, {\n      status: PageResourceStatus.Error,\n    })\n  })\n}\n\nconst doesConnectionSupportPrefetch = () => {\n  if (\n    `connection` in navigator &&\n    typeof navigator.connection !== `undefined`\n  ) {\n    if ((navigator.connection.effectiveType || ``).includes(`2g`)) {\n      return false\n    }\n    if (navigator.connection.saveData) {\n      return false\n    }\n  }\n  return true\n}\n\nconst toPageResources = (pageData, component = null) => {\n  const page = {\n    componentChunkName: pageData.componentChunkName,\n    path: pageData.path,\n    webpackCompilationHash: pageData.webpackCompilationHash,\n    matchPath: pageData.matchPath,\n  }\n\n  return {\n    component,\n    json: pageData.result,\n    page,\n  }\n}\n\nexport class BaseLoader {\n  constructor(loadComponent, matchPaths) {\n    // Map of pagePath -> Page. Where Page is an object with: {\n    //   status: PageResourceStatus.Success || PageResourceStatus.Error,\n    //   payload: PageResources, // undefined if PageResourceStatus.Error\n    // }\n    // PageResources is {\n    //   component,\n    //   json: pageData.result,\n    //   page: {\n    //     componentChunkName,\n    //     path,\n    //     webpackCompilationHash,\n    //   }\n    // }\n    this.pageDb = new Map()\n    this.inFlightDb = new Map()\n    this.pageDataDb = new Map()\n    this.prefetchTriggered = new Set()\n    this.prefetchCompleted = new Set()\n    this.loadComponent = loadComponent\n    setMatchPaths(matchPaths)\n  }\n\n  setApiRunner(apiRunner) {\n    this.apiRunner = apiRunner\n    this.prefetchDisabled = apiRunner(`disableCorePrefetching`).some(a => a)\n  }\n\n  loadPageDataJson(rawPath) {\n    const pagePath = findPath(rawPath)\n    if (this.pageDataDb.has(pagePath)) {\n      return Promise.resolve(this.pageDataDb.get(pagePath))\n    }\n\n    return loadPageDataJson({ pagePath }).then(pageData => {\n      this.pageDataDb.set(pagePath, pageData)\n\n      return pageData\n    })\n  }\n\n  findMatchPath(rawPath) {\n    return findMatchPath(rawPath)\n  }\n\n  // TODO check all uses of this and whether they use undefined for page resources not exist\n  loadPage(rawPath) {\n    const pagePath = findPath(rawPath)\n    if (this.pageDb.has(pagePath)) {\n      const page = this.pageDb.get(pagePath)\n      return Promise.resolve(page.payload)\n    }\n    if (this.inFlightDb.has(pagePath)) {\n      return this.inFlightDb.get(pagePath)\n    }\n\n    const inFlight = Promise.all([\n      this.loadAppData(),\n      this.loadPageDataJson(pagePath),\n    ])\n      .then(allData => {\n        const result = allData[1]\n        if (result.status === PageResourceStatus.Error) {\n          return {\n            status: PageResourceStatus.Error,\n          }\n        }\n\n        let pageData = result.payload\n        const { componentChunkName } = pageData\n        return this.loadComponent(componentChunkName).then(component => {\n          const finalResult = { createdAt: new Date() }\n          let pageResources\n          if (!component) {\n            finalResult.status = PageResourceStatus.Error\n          } else {\n            finalResult.status = PageResourceStatus.Success\n            if (result.notFound === true) {\n              finalResult.notFound = true\n            }\n            pageData = Object.assign(pageData, {\n              webpackCompilationHash: allData[0]\n                ? allData[0].webpackCompilationHash\n                : ``,\n            })\n            pageResources = toPageResources(pageData, component)\n            finalResult.payload = pageResources\n            emitter.emit(`onPostLoadPageResources`, {\n              page: pageResources,\n              pageResources,\n            })\n          }\n          this.pageDb.set(pagePath, finalResult)\n          // undefined if final result is an error\n          return pageResources\n        })\n      })\n      // prefer duplication with then + catch over .finally to prevent problems in ie11 + firefox\n      .then(response => {\n        this.inFlightDb.delete(pagePath)\n        return response\n      })\n      .catch(err => {\n        this.inFlightDb.delete(pagePath)\n        throw err\n      })\n\n    this.inFlightDb.set(pagePath, inFlight)\n    return inFlight\n  }\n\n  // returns undefined if loading page ran into errors\n  loadPageSync(rawPath) {\n    const pagePath = findPath(rawPath)\n    if (this.pageDb.has(pagePath)) {\n      return this.pageDb.get(pagePath).payload\n    }\n    return undefined\n  }\n\n  shouldPrefetch(pagePath) {\n    // Skip prefetching if we know user is on slow or constrained connection\n    if (!doesConnectionSupportPrefetch()) {\n      return false\n    }\n\n    // Check if the page exists.\n    if (this.pageDb.has(pagePath)) {\n      return false\n    }\n\n    return true\n  }\n\n  prefetch(pagePath) {\n    if (!this.shouldPrefetch(pagePath)) {\n      return false\n    }\n\n    // Tell plugins with custom prefetching logic that they should start\n    // prefetching this path.\n    if (!this.prefetchTriggered.has(pagePath)) {\n      this.apiRunner(`onPrefetchPathname`, { pathname: pagePath })\n      this.prefetchTriggered.add(pagePath)\n    }\n\n    // If a plugin has disabled core prefetching, stop now.\n    if (this.prefetchDisabled) {\n      return false\n    }\n\n    const realPath = findPath(pagePath)\n    // Todo make doPrefetch logic cacheable\n    // eslint-disable-next-line consistent-return\n    this.doPrefetch(realPath).then(() => {\n      if (!this.prefetchCompleted.has(pagePath)) {\n        this.apiRunner(`onPostPrefetchPathname`, { pathname: pagePath })\n        this.prefetchCompleted.add(pagePath)\n      }\n    })\n\n    return true\n  }\n\n  doPrefetch(pagePath) {\n    throw new Error(`doPrefetch not implemented`)\n  }\n\n  hovering(rawPath) {\n    this.loadPage(rawPath)\n  }\n\n  getResourceURLsForPathname(rawPath) {\n    const pagePath = findPath(rawPath)\n    const page = this.pageDataDb.get(pagePath)\n    if (page) {\n      const pageResources = toPageResources(page.payload)\n\n      return [\n        ...createComponentUrls(pageResources.page.componentChunkName),\n        createPageDataUrl(pagePath),\n      ]\n    } else {\n      return null\n    }\n  }\n\n  isPageNotFound(rawPath) {\n    const pagePath = findPath(rawPath)\n    const page = this.pageDb.get(pagePath)\n    return page && page.notFound === true\n  }\n\n  loadAppData(retries = 0) {\n    return doFetch(`${__PATH_PREFIX__}/page-data/app-data.json`).then(req => {\n      const { status, responseText } = req\n\n      let appData\n\n      if (status !== 200 && retries < 3) {\n        // Retry 3 times incase of non-200 responses\n        return this.loadAppData(retries + 1)\n      }\n\n      // Handle 200\n      if (status === 200) {\n        try {\n          const jsonPayload = JSON.parse(responseText)\n          if (jsonPayload.webpackCompilationHash === undefined) {\n            throw new Error(`not a valid app-data response`)\n          }\n\n          appData = jsonPayload\n        } catch (err) {\n          // continue regardless of error\n        }\n      }\n\n      return appData\n    })\n  }\n}\n\nconst createComponentUrls = componentChunkName =>\n  (window.___chunkMapping[componentChunkName] || []).map(\n    chunk => __PATH_PREFIX__ + chunk\n  )\n\nexport class ProdLoader extends BaseLoader {\n  constructor(asyncRequires, matchPaths) {\n    const loadComponent = chunkName =>\n      asyncRequires.components[chunkName]\n        ? asyncRequires.components[chunkName]()\n            .then(preferDefault)\n            // loader will handle the case when component is null\n            .catch(() => null)\n        : Promise.resolve()\n\n    super(loadComponent, matchPaths)\n  }\n\n  doPrefetch(pagePath) {\n    const pageDataUrl = createPageDataUrl(pagePath)\n    return prefetchHelper(pageDataUrl, {\n      crossOrigin: `anonymous`,\n      as: `fetch`,\n    })\n      .then(() =>\n        // This was just prefetched, so will return a response from\n        // the cache instead of making another request to the server\n        this.loadPageDataJson(pagePath)\n      )\n      .then(result => {\n        if (result.status !== PageResourceStatus.Success) {\n          return Promise.resolve()\n        }\n        const pageData = result.payload\n        const chunkName = pageData.componentChunkName\n        const componentUrls = createComponentUrls(chunkName)\n        return Promise.all(componentUrls.map(prefetchHelper)).then(\n          () => pageData\n        )\n      })\n  }\n\n  loadPageDataJson(rawPath) {\n    return super.loadPageDataJson(rawPath).then(data => {\n      if (data.notFound) {\n        // check if html file exist using HEAD request:\n        // if it does we should navigate to it instead of showing 404\n        return doFetch(rawPath, `HEAD`).then(req => {\n          if (req.status === 200) {\n            // page (.html file) actually exist (or we asked for 404 )\n            // returning page resources status as errored to trigger\n            // regular browser navigation to given page\n            return {\n              status: PageResourceStatus.Error,\n            }\n          }\n\n          // if HEAD request wasn't 200, return notFound result\n          // and show 404 page\n          return data\n        })\n      }\n      return data\n    })\n  }\n}\n\nlet instance\n\nexport const setLoader = _loader => {\n  instance = _loader\n}\n\nexport const publicLoader = {\n  // Deprecated methods. As far as we're aware, these are only used by\n  // core gatsby and the offline plugin, however there's a very small\n  // chance they're called by others.\n  getResourcesForPathname: rawPath => {\n    console.warn(\n      `Warning: getResourcesForPathname is deprecated. Use loadPage instead`\n    )\n    return instance.i.loadPage(rawPath)\n  },\n  getResourcesForPathnameSync: rawPath => {\n    console.warn(\n      `Warning: getResourcesForPathnameSync is deprecated. Use loadPageSync instead`\n    )\n    return instance.i.loadPageSync(rawPath)\n  },\n  enqueue: rawPath => instance.prefetch(rawPath),\n\n  // Real methods\n  getResourceURLsForPathname: rawPath =>\n    instance.getResourceURLsForPathname(rawPath),\n  loadPage: rawPath => instance.loadPage(rawPath),\n  loadPageSync: rawPath => instance.loadPageSync(rawPath),\n  prefetch: rawPath => instance.prefetch(rawPath),\n  isPageNotFound: rawPath => instance.isPageNotFound(rawPath),\n  hovering: rawPath => instance.hovering(rawPath),\n  loadAppData: () => instance.loadAppData(),\n}\n\nexport default publicLoader\n"]},"metadata":{},"sourceType":"module"}