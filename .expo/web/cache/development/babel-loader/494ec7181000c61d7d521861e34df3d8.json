{"ast":null,"code":"function _createForOfIteratorHelperLoose(o) { var i = 0; if (typeof Symbol === \"undefined\" || o[typeof Symbol === \"function\" ? Symbol.iterator : \"@@iterator\"] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } i = o[typeof Symbol === \"function\" ? Symbol.iterator : \"@@iterator\"](); return i.next.bind(i); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { match } from \"@reach/router/lib/utils\";\nimport stripPrefix from \"./strip-prefix\";\nimport normalizePagePath from \"./normalize-page-path\";\nvar pathCache = new Map();\nvar matchPaths = [];\n\nvar trimPathname = function trimPathname(rawPathname) {\n  var pathname = decodeURIComponent(rawPathname);\n  var trimmedPathname = stripPrefix(pathname, __BASE_PATH__).split(\"#\")[0].split(\"?\")[0];\n  return trimmedPathname;\n};\n\nexport var setMatchPaths = function setMatchPaths(value) {\n  matchPaths = value;\n};\nexport var findMatchPath = function findMatchPath(rawPathname) {\n  var trimmedPathname = cleanPath(rawPathname);\n\n  for (var _iterator = _createForOfIteratorHelperLoose(matchPaths), _step; !(_step = _iterator()).done;) {\n    var _ref = _step.value;\n    var matchPath = _ref.matchPath;\n    var path = _ref.path;\n\n    if (match(matchPath, trimmedPathname)) {\n      return normalizePagePath(path);\n    }\n  }\n\n  return null;\n};\nexport var findPath = function findPath(rawPathname) {\n  var trimmedPathname = trimPathname(rawPathname);\n\n  if (pathCache.has(trimmedPathname)) {\n    return pathCache.get(trimmedPathname);\n  }\n\n  var foundPath = findMatchPath(trimmedPathname);\n\n  if (!foundPath) {\n    foundPath = cleanPath(rawPathname);\n  }\n\n  pathCache.set(trimmedPathname, foundPath);\n  return foundPath;\n};\nexport var cleanPath = function cleanPath(rawPathname) {\n  var trimmedPathname = trimPathname(rawPathname);\n  var foundPath = trimmedPathname;\n\n  if (foundPath === \"/index.html\") {\n    foundPath = \"/\";\n  }\n\n  foundPath = normalizePagePath(foundPath);\n  return foundPath;\n};","map":{"version":3,"sources":["/home/pc/Public/zenith/gatsby-firebase-starter-NEW/.cache/find-path.js"],"names":["match","stripPrefix","normalizePagePath","pathCache","Map","matchPaths","trimPathname","rawPathname","pathname","decodeURIComponent","trimmedPathname","__BASE_PATH__","split","setMatchPaths","value","findMatchPath","cleanPath","matchPath","path","findPath","has","get","foundPath","set"],"mappings":";;;;;;AAAA,SAASA,KAAT,QAAsB,yBAAtB;AACA,OAAOC,WAAP;AACA,OAAOC,iBAAP;AAEA,IAAMC,SAAS,GAAG,IAAIC,GAAJ,EAAlB;AACA,IAAIC,UAAU,GAAG,EAAjB;;AAEA,IAAMC,YAAY,GAAG,SAAfA,YAAe,CAAAC,WAAW,EAAI;AAClC,MAAMC,QAAQ,GAAGC,kBAAkB,CAACF,WAAD,CAAnC;AAEA,MAAMG,eAAe,GAAGT,WAAW,CAACO,QAAD,EAAWG,aAAX,CAAX,CAErBC,KAFqB,MAEV,CAFU,EAIrBA,KAJqB,MAIV,CAJU,CAAxB;AAMA,SAAOF,eAAP;AACD,CAVD;;AAiBA,OAAO,IAAMG,aAAa,GAAG,SAAhBA,aAAgB,CAAAC,KAAK,EAAI;AACpCT,EAAAA,UAAU,GAAGS,KAAb;AACD,CAFM;AAYP,OAAO,IAAMC,aAAa,GAAG,SAAhBA,aAAgB,CAAAR,WAAW,EAAI;AAC1C,MAAMG,eAAe,GAAGM,SAAS,CAACT,WAAD,CAAjC;;AAEA,uDAAkCF,UAAlC,wCAA8C;AAAA;AAAA,QAAjCY,SAAiC,QAAjCA,SAAiC;AAAA,QAAtBC,IAAsB,QAAtBA,IAAsB;;AAC5C,QAAIlB,KAAK,CAACiB,SAAD,EAAYP,eAAZ,CAAT,EAAuC;AACrC,aAAOR,iBAAiB,CAACgB,IAAD,CAAxB;AACD;AACF;;AAED,SAAO,IAAP;AACD,CAVM;AAoBP,OAAO,IAAMC,QAAQ,GAAG,SAAXA,QAAW,CAAAZ,WAAW,EAAI;AACrC,MAAMG,eAAe,GAAGJ,YAAY,CAACC,WAAD,CAApC;;AAEA,MAAIJ,SAAS,CAACiB,GAAV,CAAcV,eAAd,CAAJ,EAAoC;AAClC,WAAOP,SAAS,CAACkB,GAAV,CAAcX,eAAd,CAAP;AACD;;AAED,MAAIY,SAAS,GAAGP,aAAa,CAACL,eAAD,CAA7B;;AAEA,MAAI,CAACY,SAAL,EAAgB;AACdA,IAAAA,SAAS,GAAGN,SAAS,CAACT,WAAD,CAArB;AACD;;AAEDJ,EAAAA,SAAS,CAACoB,GAAV,CAAcb,eAAd,EAA+BY,SAA/B;AAEA,SAAOA,SAAP;AACD,CAhBM;AAyBP,OAAO,IAAMN,SAAS,GAAG,SAAZA,SAAY,CAAAT,WAAW,EAAI;AACtC,MAAMG,eAAe,GAAGJ,YAAY,CAACC,WAAD,CAApC;AAEA,MAAIe,SAAS,GAAGZ,eAAhB;;AACA,MAAIY,SAAS,kBAAb,EAAiC;AAC/BA,IAAAA,SAAS,MAAT;AACD;;AAEDA,EAAAA,SAAS,GAAGpB,iBAAiB,CAACoB,SAAD,CAA7B;AAEA,SAAOA,SAAP;AACD,CAXM","sourcesContent":["import { match } from \"@reach/router/lib/utils\"\nimport stripPrefix from \"./strip-prefix\"\nimport normalizePagePath from \"./normalize-page-path\"\n\nconst pathCache = new Map()\nlet matchPaths = []\n\nconst trimPathname = rawPathname => {\n  const pathname = decodeURIComponent(rawPathname)\n  // Remove the pathPrefix from the pathname.\n  const trimmedPathname = stripPrefix(pathname, __BASE_PATH__)\n    // Remove any hashfragment\n    .split(`#`)[0]\n    // Remove search query\n    .split(`?`)[0]\n\n  return trimmedPathname\n}\n\n/**\n * Set list of matchPaths\n *\n * @param {Array<{path: string, matchPath: string}>} value collection of matchPaths\n */\nexport const setMatchPaths = value => {\n  matchPaths = value\n}\n\n/**\n * Return a matchpath url\n * if `match-paths.json` contains `{ \"/foo*\": \"/page1\", ...}`, then\n * `/foo?bar=far` => `/page1`\n *\n * @param {string} rawPathname A raw pathname\n * @return {string|null}\n */\nexport const findMatchPath = rawPathname => {\n  const trimmedPathname = cleanPath(rawPathname)\n\n  for (const { matchPath, path } of matchPaths) {\n    if (match(matchPath, trimmedPathname)) {\n      return normalizePagePath(path)\n    }\n  }\n\n  return null\n}\n\n// Given a raw URL path, returns the cleaned version of it (trim off\n// `#` and query params), or if it matches an entry in\n// `match-paths.json`, its matched path is returned\n//\n// E.g. `/foo?bar=far` => `/foo`\n//\n// Or if `match-paths.json` contains `{ \"/foo*\": \"/page1\", ...}`, then\n// `/foo?bar=far` => `/page1`\nexport const findPath = rawPathname => {\n  const trimmedPathname = trimPathname(rawPathname)\n\n  if (pathCache.has(trimmedPathname)) {\n    return pathCache.get(trimmedPathname)\n  }\n\n  let foundPath = findMatchPath(trimmedPathname)\n\n  if (!foundPath) {\n    foundPath = cleanPath(rawPathname)\n  }\n\n  pathCache.set(trimmedPathname, foundPath)\n\n  return foundPath\n}\n\n/**\n * Clean a url and converts /index.html => /\n * E.g. `/foo?bar=far` => `/foo`\n *\n * @param {string} rawPathname A raw pathname\n * @return {string}\n */\nexport const cleanPath = rawPathname => {\n  const trimmedPathname = trimPathname(rawPathname)\n\n  let foundPath = trimmedPathname\n  if (foundPath === `/index.html`) {\n    foundPath = `/`\n  }\n\n  foundPath = normalizePagePath(foundPath)\n\n  return foundPath\n}\n"]},"metadata":{},"sourceType":"module"}