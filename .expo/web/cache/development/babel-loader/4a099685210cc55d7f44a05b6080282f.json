{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { reportError, clearError } from \"./error-overlay-handler\";\nimport normalizePagePath from \"./normalize-page-path\";\nvar socket = null;\nvar staticQueryData = {};\nvar pageQueryData = {};\nvar isInitialized = false;\nexport var getStaticQueryData = function getStaticQueryData() {\n  return staticQueryData;\n};\nexport var getPageQueryData = function getPageQueryData() {\n  return pageQueryData;\n};\nexport var getIsInitialized = function getIsInitialized() {\n  return isInitialized;\n};\nexport default function socketIo() {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (!socket) {\n      try {\n        socket = io();\n\n        var didDataChange = function didDataChange(msg, queryData) {\n          var id = msg.type === \"staticQueryResult\" ? msg.payload.id : normalizePagePath(msg.payload.id);\n          return !(id in queryData) || JSON.stringify(msg.payload.result) !== JSON.stringify(queryData[id]);\n        };\n\n        socket.on(\"message\", function (msg) {\n          if (msg.type === \"staticQueryResult\") {\n            if (didDataChange(msg, staticQueryData)) {\n              staticQueryData = _objectSpread(_objectSpread({}, staticQueryData), {}, _defineProperty({}, msg.payload.id, msg.payload.result));\n            }\n          } else if (msg.type === \"pageQueryResult\") {\n            if (didDataChange(msg, pageQueryData)) {\n              pageQueryData = _objectSpread(_objectSpread({}, pageQueryData), {}, _defineProperty({}, normalizePagePath(msg.payload.id), msg.payload.result));\n            }\n          } else if (msg.type === \"overlayError\") {\n            if (msg.payload.message) {\n              reportError(msg.payload.id, msg.payload.message);\n            } else {\n              clearError(msg.payload.id);\n            }\n          }\n\n          if (msg.type && msg.payload) {\n            ___emitter.emit(msg.type, msg.payload);\n          }\n        });\n      } catch (err) {\n        console.error(\"Could not connect to socket.io on dev server.\");\n      }\n    }\n\n    return socket;\n  } else {\n    return null;\n  }\n}\nvar inFlightGetPageDataPromiseCache = {};\n\nfunction getPageData(pathname) {\n  pathname = normalizePagePath(pathname);\n\n  if (inFlightGetPageDataPromiseCache[pathname]) {\n    return inFlightGetPageDataPromiseCache[pathname];\n  } else {\n    inFlightGetPageDataPromiseCache[pathname] = new Promise(function (resolve) {\n      if (pageQueryData[pathname]) {\n        delete inFlightGetPageDataPromiseCache[pathname];\n        resolve(pageQueryData[pathname]);\n      } else {\n        var onPageDataCallback = function onPageDataCallback(msg) {\n          if (msg.type === \"pageQueryResult\" && normalizePagePath(msg.payload.id) === pathname) {\n            socket.off(\"message\", onPageDataCallback);\n            delete inFlightGetPageDataPromiseCache[pathname];\n            resolve(pageQueryData[pathname]);\n          }\n        };\n\n        socket.on(\"message\", onPageDataCallback);\n        socket.emit(\"getDataForPath\", pathname);\n      }\n    });\n  }\n\n  return inFlightGetPageDataPromiseCache[pathname];\n}\n\nfunction registerPath(path) {\n  socket.emit(\"registerPath\", path);\n}\n\nfunction unregisterPath(path) {\n  socket.emit(\"unregisterPath\", path);\n}\n\nexport { getPageData, registerPath, unregisterPath };","map":{"version":3,"sources":["/home/pc/Public/zenith/gatsby-firebase-starter-NEW/.cache/socketIo.js"],"names":["reportError","clearError","normalizePagePath","socket","staticQueryData","pageQueryData","isInitialized","getStaticQueryData","getPageQueryData","getIsInitialized","socketIo","process","env","NODE_ENV","io","didDataChange","msg","queryData","id","type","payload","JSON","stringify","result","on","message","___emitter","emit","err","console","error","inFlightGetPageDataPromiseCache","getPageData","pathname","Promise","resolve","onPageDataCallback","off","registerPath","path","unregisterPath"],"mappings":"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","sourcesContent":["import { reportError, clearError } from \"./error-overlay-handler\"\nimport normalizePagePath from \"./normalize-page-path\"\n\nlet socket = null\n\nlet staticQueryData = {}\nlet pageQueryData = {}\nlet isInitialized = false\n\nexport const getStaticQueryData = () => staticQueryData\nexport const getPageQueryData = () => pageQueryData\nexport const getIsInitialized = () => isInitialized\n\nexport default function socketIo() {\n  if (process.env.NODE_ENV !== `production`) {\n    if (!socket) {\n      // Try to initialize web socket if we didn't do it already\n      try {\n        // eslint-disable-next-line no-undef\n        socket = io()\n\n        const didDataChange = (msg, queryData) => {\n          const id =\n            msg.type === `staticQueryResult`\n              ? msg.payload.id\n              : normalizePagePath(msg.payload.id)\n          return (\n            !(id in queryData) ||\n            JSON.stringify(msg.payload.result) !== JSON.stringify(queryData[id])\n          )\n        }\n\n        socket.on(`message`, msg => {\n          if (msg.type === `staticQueryResult`) {\n            if (didDataChange(msg, staticQueryData)) {\n              staticQueryData = {\n                ...staticQueryData,\n                [msg.payload.id]: msg.payload.result,\n              }\n            }\n          } else if (msg.type === `pageQueryResult`) {\n            if (didDataChange(msg, pageQueryData)) {\n              pageQueryData = {\n                ...pageQueryData,\n                [normalizePagePath(msg.payload.id)]: msg.payload.result,\n              }\n            }\n          } else if (msg.type === `overlayError`) {\n            if (msg.payload.message) {\n              reportError(msg.payload.id, msg.payload.message)\n            } else {\n              clearError(msg.payload.id)\n            }\n          }\n          if (msg.type && msg.payload) {\n            ___emitter.emit(msg.type, msg.payload)\n          }\n        })\n      } catch (err) {\n        console.error(`Could not connect to socket.io on dev server.`)\n      }\n    }\n    return socket\n  } else {\n    return null\n  }\n}\n\nconst inFlightGetPageDataPromiseCache = {}\nfunction getPageData(pathname) {\n  pathname = normalizePagePath(pathname)\n  if (inFlightGetPageDataPromiseCache[pathname]) {\n    return inFlightGetPageDataPromiseCache[pathname]\n  } else {\n    inFlightGetPageDataPromiseCache[pathname] = new Promise(resolve => {\n      if (pageQueryData[pathname]) {\n        delete inFlightGetPageDataPromiseCache[pathname]\n        resolve(pageQueryData[pathname])\n      } else {\n        const onPageDataCallback = msg => {\n          if (\n            msg.type === `pageQueryResult` &&\n            normalizePagePath(msg.payload.id) === pathname\n          ) {\n            socket.off(`message`, onPageDataCallback)\n            delete inFlightGetPageDataPromiseCache[pathname]\n            resolve(pageQueryData[pathname])\n          }\n        }\n        socket.on(`message`, onPageDataCallback)\n\n        socket.emit(`getDataForPath`, pathname)\n      }\n    })\n  }\n  return inFlightGetPageDataPromiseCache[pathname]\n}\n\n// Tell websocket-manager.js the new path we're on.\n// This will help the backend prioritize queries for this\n// path.\nfunction registerPath(path) {\n  socket.emit(`registerPath`, path)\n}\n\n// Unregister the former path\nfunction unregisterPath(path) {\n  socket.emit(`unregisterPath`, path)\n}\n\nexport { getPageData, registerPath, unregisterPath }\n"]},"metadata":{},"sourceType":"module"}